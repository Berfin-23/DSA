# 61. 3Sum (LeetCode) - Medium

Given an integer array `nums`, return all the triplets `[nums[i], nums[j], nums[k]]` such that `i != j`, `i != k`, and `j != k`, and `nums[i] + nums[j] + nums[k] == 0`.

Notice that the solution set must not contain duplicate triplets.

[Link for the question](https://leetcode.com/problems/3sum/)

## Examples

**Example 1:**

> **Input:** `nums = [-1,0,1,2,-1,-4]`  
> **Output:** `[[-1,-1,2],[-1,0,1]]`  
> **Explanation:**
>
> - `nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0`
> - `nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0`
> - `nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0`
>
> The distinct triplets are `[-1,0,1]` and `[-1,-1,2]`.

**Example 2:**

> **Input:** `nums = [0,1,1]`  
> **Output:** `[]`  
> **Explanation:** The only possible triplet does not sum up to 0.

**Example 3:**

> **Input:** `nums = [0,0,0]`  
> **Output:** `[[0,0,0]]`  
> **Explanation:** The only possible triplet sums up to 0.

## Constraints

- `3 <= nums.length <= 3000`
- `-10^5 <= nums[i] <= 10^5`

## Solution (Python)

Sort the array and use a two-pointer approach. For each element, use two pointers to find pairs that sum with the current element to reach zero. Skip duplicates to ensure unique triplets.

```python
from typing import List

def threeSum(nums: List[int]) -> List[List[int]]:
    """Finds all unique triplets in nums that sum to zero.

    Time Complexity: O(n^2) due to sorting + nested loops
    Space Complexity: O(k) for the output, where k is the number of triplets
    """
    results = []
    nums.sort()
    n = len(nums)

    for i in range(n - 2):
        # Early termination: if smallest element > 0, no way to sum to 0
        if nums[i] > 0:
            break

        # Skip duplicate elements
        if i > 0 and nums[i] == nums[i - 1]:
            continue

        left = i + 1
        right = n - 1

        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]

            if current_sum == 0:
                results.append([nums[i], nums[left], nums[right]])

                left += 1
                right -= 1

                # Skip duplicates for left pointer
                while left < right and nums[left] == nums[left - 1]:
                    left += 1

                # Skip duplicates for right pointer
                while left < right and nums[right] == nums[right + 1]:
                    right -= 1

            elif current_sum > 0:
                right -= 1
            else:
                left += 1

    return results


if __name__ == "__main__":
    # Quick sanity checks
    print(threeSum([-1, 0, 1, 2, -1, -4]))  # [[-1,-1,2],[-1,0,1]]
    print(threeSum([0, 1, 1]))               # []
    print(threeSum([0, 0, 0]))               # [[0,0,0]]
```
